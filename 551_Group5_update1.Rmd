---
title: "551 Case Study Group5"
author: "Ethan Straub, Leila Naderi, Benjamin Fraizer"
date: "2024-09-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Introduction

In the dataset, the only non-quantitative variable is the golfer's name. This variable won't be used in a model because each golfer has a unique name, and it doesn't make sense that a person's name impacts the amount of prize money that a golfer wins.

# Summary Statistics and Graphs

```{r}
library(ggcorrplot)
library(ggplot2) 
library(scales) 
library(ggrepel) 
df = read.csv("LPGA.csv")
# Taking names out of the design matrix
data = df[,-1]
pairs(data)
```

```{r}
corMat = cor(data)
ggcorrplot(corMat)
```

From the pairs plot, we can see that the distribution of the response variable (Prize money per round) is highly skewed right. It may be a good idea to log transform this variable in a model.

There are no exceptionally strong relationships between variables, but there are a few noticeable trends. 

Golfers who hit longer drives on average tend to hit the fairway less. This reflects the trade off between power and accuracy. It is easy to hit a ball far, and it is easy to hit a ball short with a good line. But it is difficult to hit it far and with the right line. We can create a variable that reflects a golfer's long game by multiplying these variables together after standardizing (to make the contribution from each variable the same).

Average sand shots and percent green have a decently large negative correlation. Most sand traps in golf are close to the green. So if a golfer misses a lot of greens, it is likely that they hit sand traps instead.

Here are some other relationships in the data that make intuitive sense. A better golfer who makes more money per round will generally have longer drives, more accurate fairway and green shots, less putts, hit less sand traps, and hit good shots from the sand. 

Surprisingly, the highest correlation between two variables in the dataset is between number of rounds played and prize money per round. Perhaps the better golfers who make more money make it into more tournaments.

The rounds variable can be used to make new variables that are scaled measures of recognizable measures.

Scaled total distance = average distance * number of rounds

Scaled total putts = average putts * number of rounds

Scaled total sand shots = average sand shots * number of rounds

Scaled total fairway shots = percent of fairway shots * number of rounds

Scaled total green shots = percent of green shots * number of rounds

Scaled total sand saves = percent of sand saves * number of rounds

```{r}
data$totDist = data$avedist * data$rounds
data$totPutts = data$aveputt * data$rounds
data$totSand = data$avesand * data$rounds
data$totFrwy = data$pctfrwy * data$rounds
data$totGrn = data$pctgrn * data$rounds
data$totSsv = data$pctsndsv * data$rounds
przrnd = data$przrnd
dta_temp = as.data.frame(scale(data[,c(1:7, 9:14)]))
dta_temp$longGame = dta_temp$avedist * dta_temp$pctfrwy
std_designMat = as.data.frame(scale(dta_temp))

corMat2 = cor(std_designMat)
ggcorrplot(corMat2)
```


# Analysis

```{r}
# Functions

suppressMessages(library(rstanarm))
suppressMessages(library(bayesplot))
suppressMessages(library(loo))

fit = function(Y = przrnd, logY = TRUE, X = std_designMat, prior = "normal", scale = 2.5, p0 = 4){
  fullMat = cbind(X, Y)
  if(prior == "normal"){
    if(logY == TRUE){
    fit = stan_glm(log(Y) ~ . , data = fullMat, 
                 prior=normal(scale=scale), refresh = 0)
    }
    else{
    fit = stan_glm(Y ~ . , data = fullMat, 
                prior=normal(scale=scale), refresh = 0)
    }
  }
  else if(prior == "horseshoe"){
    p = ncol(X)
    n = nrow(X)
    global_scale <- (p0/(p - p0))/sqrt(n)
    if(logY == TRUE){
    slab_scale <- sqrt(0.3/p0)*sd(log(fullMat$Y))
    fit <- stan_glm(log(Y) ~ ., data=fullMat, refresh=0,
    prior=hs(global_scale=global_scale,
    slab_scale=slab_scale))
    }
    else{
    slab_scale <- sqrt(0.3/p0)*sd(fullMat$Y)
    fit <- stan_glm(Y ~ ., data=fullMat, refresh=0,
    prior=hs(global_scale=global_scale,
    slab_scale=slab_scale))
    }
  }
  else{
    print("spelling error on the prior")
  }
  return(fit)
}

plots = function(logY = TRUE, X = std_designMat, coefDist = TRUE, residFit = TRUE, Y = przrnd, prior = "normal", scale = 2.5, p0 = 4 ){
  fit = fit(Y, logY, X, prior, scale, p0)
  if(residFit == TRUE){
    plot(fit$fitted.values, fit$residuals, xlab = "Fitted Values", 
         ylab = "Residuals", abline(h=c(-sigma(fit), 0, sigma(fit)), lwd=3,
                                    lty=c(2, 1, 2), col = "gray"), pch = 16)
  }
  if(coefDist == TRUE){
    pt <- mcmc_areas(as.matrix(fit), pars=vars(-'(Intercept)',-sigma),
                 prob_outer=0.95, area_method = "scaled height") +
    xlim(c(-1.2,1.2))
    pt <- pt + scale_y_discrete(limits = rev(levels(pt$data$parameter))) +        ggtitle("Posterior Distribution of Slopes")
    pt
  }
}


compare = function(Y = przrnd, logY = c(TRUE, TRUE), X = list(std_designMat, std_designMat[,c(2:8,14)]), prior = c("normal", "horseshoe"), scale = c(.25, 1), p0 = c(4,4), kf = FALSE, k = 5){
  numModels = length(prior)
  fit_list = vector("list", length = numModels)
  for(i in 1:numModels){
    fit = fit(Y, logY[i], X[[i]], prior[i], scale[i], p0[i])
    fit_list[[i]] = fit
  }
  objList = vector("list", length = numModels)
  if(kf == TRUE){
    for(i in 1:numModels){
      if(i == 1){
        model_1 = fit_list[[i]]
        objList[[i]] = rstanarm::kfold(model_1, K = k, scale = NULL)
      }
      if(i == 2){
        model_2 = fit_list[[i]]
        objList[[i]] = rstanarm::kfold(model_2, K = k, scale = NULL)
      }
      if(i == 3){
        model_3 = fit_list[[i]]
        objList[[i]] = rstanarm::kfold(model_3, K = k, scale = NULL)
      }
    }
  }
  else{
    for(i in 1:numModels){
      if(i == 1){
        model_1 = fit_list[[i]]
        objList[[i]] = loo(model_1)
      }
      if(i == 2){
        model_2 = fit_list[[i]]
        objList[[i]] = loo(model_2)
      }
      if(i == 3){
        model_3 = fit_list[[i]]
        objList[[i]] = loo(model_3)
      }
    }
  }
  do.call(rstanarm::loo_compare, objList)
}
```


```{r}
plots(X = std_designMat[,c(2:8,14)])

#suppressMessages(plots(X = std_designMat[,c(2:8,14)]))

compare(X = list(std_designMat[,c(2,14)], std_designMat[,c(4, 9, 14)]), p0 = c(2,2))


```

```{r}
Y = as.numeric(przrnd)
df = cbind(std_designMat, Y)
f = stan_glm(log(Y) ~., data = df, refresh = 0)
fl = fit()
#folds <-kfold_split_random(K=4, N=100)
t = loo::kfold(f, K = 2, scale = NULL)
```




# Results and Conclusion